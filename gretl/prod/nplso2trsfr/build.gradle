apply plugin: 'groovy'

repositories {
    jcenter()
}

configurations {
    groovyScript
}

dependencies {
    groovyScript localGroovy()
    implementation 'org.postgresql:postgresql:42.2.2'
}

import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.TransferSet
import java.nio.file.Paths

// Export-Verzeichnis
def pathToTempFolder = System.getProperty("java.io.tmpdir")
def pathToExportFolder = Paths.get(pathToTempFolder, 'export_data')

def GROUP = "Datenumbau NPLSO -> Transferstruktur (Staging)"

task deleteStaging(type: SqlExecutor) {
    description = "Löscht die Daten aus dem Staging-Schema ($dbSchemaOerebNutzungsplanung)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = ["delete_oereb_npl_staging.sql"]
}

// Hinweise auf die gesetzlichen Grundlagen muss in einem 
// nachgelagerten Schritt passieren und kann nicht direkt
// in der langen CTE erfolgen. Updates von CTE direkt
// gehen nicht, sondern nur auf bereits vorhandene Daten
// in Tabellen.
// Ebenfalls in einer nachgelagerter Query werden die
// zustaendigen Stellen nachgeführt.
task insertStaging(type: SqlExecutor) {
    description = "Baut die Daten aus dem kantonalen Modell in das Rahmenmodell um und speichert sie im Staging-Schema ($dbSchemaOerebNutzungsplanung)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = ["insert_oereb_npl_staging.sql", "insert_oereb_npl_staging_legal_basis.sql", "update_oereb_npl_staging_responsible_office.sql", "update_oereb_npl_staging_fix_empty_responsible_office_errors.sql"]
}

task exportLandUsePlansToXtf(type: Ili2pgExport) {
    description = "Export die Nutzungsplanungsdaten in das OEREB-Rahmenmodell (Transferstruktur) aus dem Staging-Schema ($dbSchemaOerebNutzungsplanung)."
    group = GROUP
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelTransferstruktur
    dbschema = dbSchemaOerebNutzungsplanung
    dataset = "ch.so.arp.nutzungsplanung"
    dataFile = file(Paths.get(pathToExportFolder.toString(), xtfOerebLandUsePlanFileName))
    disableValidation = true

    doLast {
        println "File exported to: " + pathToExportFolder
    }
}

task updateLegendEntrySymbols(type: JavaExec) {
    description = "Create symbols for legend entry from WMS requests. PRE-ALPHA!!!! (Grundnutzung only!)"
    group = GROUP
    classpath = sourceSets.main.runtimeClasspath + configurations.groovyScript
    main = 'groovy.ui.GroovyMain'
    args '-e', '''\
import groovy.xml.*
import groovy.sql.*

import java.net.URLEncoder
import java.nio.file.Files

def dbUrl = "jdbc:postgresql://192.168.50.8/edit"
def dbUser = "ddluser"
def dbPassword = "ddluser"
def dbDriver = "org.postgresql.Driver"
def sql = Sql.newInstance(dbUrl, dbUser, dbPassword, dbDriver)

def baseUrl = "http://192.168.50.8/cgi-bin/qgis_mapserv.fcgi?map=/vagrant/qgis/wms/ch.so.arp.nutzungsplanung.oereb.qgs"
def layerName = "ch.so.arp.nutzungsplanung.grundnutzung.oereb"

def sldFile = new File(layerName+".sld")
sldFile.newWriter()
//println baseUrl + "&SERVICE=WMS&REQUEST=GetStyles&LAYERS=" + layerName + "&SLD_VERSION=1.1.0"
sldFile << new URL(baseUrl + "&SERVICE=WMS&REQUEST=GetStyles&LAYERS=" + layerName + "&SLD_VERSION=1.1.0").getText()

def xml = new XmlSlurper().parse(layerName+".sld")

xml.NamedLayer.UserStyle.FeatureTypeStyle.Rule.each { rule ->
    println rule.Name
    def ruleName = rule.Name.toString()

    // Hier geht es wohl nicht ohne Bedingungen, die man zusammen abmacht.
    // Dh. ich muss irgendwie die Zuweisung der Regel (resp. des Names) zum
    // ArtCode machen können. 
    // Eventuell Artcode in "Abstract" reinschreiben.
    // Davon ausgehen, dass der Filter immer genau gleich aufgebaut ist
    // (z.B. PropertyIsEqualTo), kann ich ja nicht.
    println rule.Filter.PropertyIsEqualTo.Literal
    def artCode = rule.Filter.PropertyIsEqualTo.Literal.toString()

    def encodedRuleName = URLEncoder.encode(ruleName, "UTF-8");
    println encodedRuleName

    // Grösse des Images plusminus berechnet für die 300 dpi. (WMS-Spec ist circa 90 dpi).
    //def legendGraphicUrl = baseUrl + "&SERVICE=WMS&REQUEST=GetLegendGraphic&LAYER=" + layerName + "&FORMAT=image/png&RULELABEL=false&LAYERTITLE=false&RULE=" + encodedRuleName + "&HEIGHT=70&WIDTH=94&SYMBOLHEIGHT=6&SYMBOLWIDTH=8&DPI=300" 
    def legendGraphicUrl = baseUrl + "&SERVICE=WMS&REQUEST=GetLegendGraphic&LAYER=" + layerName + "&FORMAT=image/png&RULELABEL=false&LAYERTITLE=false&RULE=" + encodedRuleName + "&HEIGHT=35&WIDTH=70&SYMBOLHEIGHT=3&SYMBOLWIDTH=6&DPI=300" 
    println legendGraphicUrl

    try {
        def fileName = ruleName.toString().replaceAll(" ","_").replaceAll("/","-") + "_" + artCode + ".png"
        def iconFile = new File(fileName).newOutputStream()
        iconFile << new URL(legendGraphicUrl).openStream()
        iconFile.close()

        byte[] fileContent = Files.readAllBytes(new File(fileName).toPath())

        sql.executeUpdate "UPDATE arp_npl_oereb.transferstruktur_legendeeintrag SET legendetext_de = $ruleName, symbol = $fileContent WHERE artcode = $artCode"
    } catch (java.io.FileNotFoundException e) {
        println e.getMessage()
    }
    println "******"   
}
sql.close()
'''
}